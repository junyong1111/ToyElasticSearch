[
    {
      "keyword": "트랜잭션",
      "topic": "데이터베이스",
      "level": {
        "concept": "트랜잭션(Transaction)은 데이터베이스에서 하나의 논리적인 작업 단위로, 여러 작업을 하나의 작업처럼 묶어서 처리한다. 예: 계좌 이체에서 출금과 입금은 반드시 함께 이루어져야 한다.",
        "intermediate": "트랜잭션은 ACID 속성(원자성, 일관성, 격리성, 지속성)을 만족해야 한다. 원자성은 작업이 모두 반영되거나 전혀 반영되지 않아야 함을, 일관성은 트랜잭션 전후 데이터베이스가 일관된 상태여야 함을, 격리성은 동시 실행 트랜잭션이 서로 영향을 주지 않아야 함을, 지속성은 완료된 트랜잭션의 결과가 영구적으로 반영되어야 함을 의미한다.",
        "advanced": "트랜잭션 간의 충돌을 방지하기 위해 격리 수준(Isolation Level)이 존재하며, 이는 동시성 문제인 Dirty Read, Non-Repeatable Read, Phantom Read 등을 해결하기 위해 조정된다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Transaction.md"
      ]
    },
    {
      "keyword": "정규화 / 반정규화",
      "topic": "데이터베이스",
      "level": {
        "concept": "정규화는 데이터 중복을 제거하고 일관성을 유지하기 위해 테이블을 나누는 과정이다. 반정규화는 성능 향상을 위해 일부 정규화를 되돌리는 작업이다.",
        "intermediate": "1NF는 컬럼이 원자값을 갖도록 하고, 2NF는 부분 함수 종속 제거, 3NF는 이행적 종속 제거를 목표로 한다. 반정규화는 JOIN 비용이 높거나 실시간 처리에 이슈가 있을 때 사용된다.",
        "advanced": "정규화가 과도하면 JOIN이 늘어 성능 저하가 발생할 수 있다. 반정규화는 성능을 얻는 대신 일관성 관리 비용이 증가하므로, 상황에 따라 정규화/반정규화를 적절히 조합해야 한다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/정규화(Normalization).md"
      ]
    },
    {
      "keyword": "인덱스",
      "topic": "데이터베이스",
      "level": {
        "concept": "인덱스(Index)는 테이블의 특정 컬럼에 대한 검색 속도를 빠르게 하기 위해 사용하는 자료 구조이다. 책의 목차처럼 원하는 데이터를 빨리 찾을 수 있게 해준다.",
        "intermediate": "RDB에서는 B-Tree 기반 인덱스가 기본이며, 해시 인덱스, 비트맵 인덱스 등도 존재한다. 역인덱스(Inverted Index)는 단어를 키로 해당 단어가 포함된 문서를 찾는 구조로, 검색 엔진에서 많이 사용된다. SELECT 속도는 증가하지만 INSERT/UPDATE/DELETE 시 인덱스 유지 비용이 발생한다.",
        "advanced": "복합(멀티컬럼) 인덱스는 여러 컬럼을 함께 인덱싱하며, 왼쪽 컬럼부터 순서대로 적용된다. 예를 들어 (이름, 나이) 인덱스는 이름으로 먼저 찾고 같은 이름 내에서 나이로 정렬된다. 따라서 이름만으로 검색할 때는 효과적이지만, 나이만으로 검색할 때는 효과가 없다. GIN, GiST 인덱스는 JSONB나 공간 데이터 등 복잡한 형태에도 적용된다. 쿼리 계획(Execution Plan)을 통해 인덱스 사용 여부를 분석한다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/%5BDB%5D%20Index.md"
      ]
    },
    {
      "keyword": "조인",
      "topic": "데이터베이스",
      "level": {
        "concept": "조인(Join)은 여러 테이블의 관련 데이터를 결합하는 SQL 연산이다. 예를 들어 학생 테이블과 성적 테이블을 학생 번호로 연결할 수 있다.",
        "intermediate": "INNER JOIN은 교집합, LEFT JOIN은 기준 테이블을 기준으로 결합하며, RIGHT JOIN, FULL OUTER JOIN 등 다양한 종류가 있다. ON, USING 절을 통해 조건을 설정한다.",
        "advanced": "조인은 해시 조인, 중첩 루프 조인, 머지 조인 등으로 내부 구현되며, 대량의 데이터를 처리할 경우 쿼리 최적화가 중요하다. Index Join이나 Materialized View도 성능 개선에 활용된다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/%5BDATABASE%20SQL%5D%20JOIN.md"
      ]
    },
    {
      "keyword": "뷰",
      "topic": "데이터베이스",
      "level": {
        "concept": "뷰(View)는 하나 이상의 테이블을 기반으로 생성된 가상의 테이블이다. 실제 데이터를 저장하지 않으며, SELECT 문으로 정의된다.",
        "intermediate": "뷰는 복잡한 쿼리를 재사용하거나 보안 목적으로 테이블의 일부분만 사용자에게 제공할 때 유용하다. 일반 뷰는 읽기 전용이고, 물리적 저장이 필요한 경우에는 Materialized View를 사용한다.",
        "advanced": "뷰의 성능은 정의된 쿼리 복잡도에 따라 달라지며, 인덱스를 적용할 수 없다. 대신 DBMS는 뷰를 내부적으로 펼쳐서 실행 계획에 포함시킨다. WITH CHECK OPTION을 사용하면 뷰 기반의 UPDATE/INSERT도 제한할 수 있다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/View.md"
      ]
    },
    {
      "keyword": "쿼리 최적화",
      "topic": "데이터베이스",
      "level": {
        "concept": "쿼리 최적화(Query Optimization)는 SQL 실행 성능을 향상시키기 위해 실행 계획을 개선하거나 쿼리 구조를 조정하는 작업이다. SELECT 문에서 JOIN, WHERE, ORDER BY 등이 주요 대상이다.",
        "intermediate": "DBMS는 옵티마이저를 통해 여러 실행 계획 중 비용이 가장 적은 계획을 선택한다. 인덱스 사용 여부, 테이블 순서, 조인 방식(Nested Loop, Hash Join 등)이 쿼리 성능을 좌우한다.",
        "advanced": "실무에서는 EXPLAIN, ANALYZE 명령으로 실제 실행 계획을 확인하고, 서브쿼리 → JOIN 전환, 인덱스 힌트, CTE 사용 등으로 성능을 개선한다. 성능 병목 구간을 정확히 파악하는 것이 핵심이다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Execution%20Plan.md"
      ]
    },
    {
      "keyword": "격리 수준 (Isolation Level)",
      "topic": "데이터베이스",
      "level": {
        "concept": "격리 수준은 동시에 실행되는 트랜잭션 간 간섭을 어느 정도 허용할지를 정의하는 트랜잭션의 ACID 속성 중 하나이다.",
        "intermediate": "대표적인 문제로는 Dirty Read(커밋되지 않은 변경 데이터 읽기), Non-repeatable Read(같은 트랜잭션 내에서 같은 데이터를 두 번 읽을 때 값이 다름), Phantom Read(트랜잭션 도중 없던 행이 생기거나 있던 행이 사라지는 현상)가 있으며,이를 해결하기 위해 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE의 네 가지 수준이 있다.",
        "advanced": "격리 수준이 높을수록 데이터 정합성은 보장되지만, 락 충돌로 인해 처리 성능이 떨어질 수 있다. InnoDB는 기본적으로 REPEATABLE READ를 사용하며, 다중 버전 제어(MVCC)를 통해 격리성과 동시성을 동시에 확보한다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Transaction%20Isolation%20Level.md"
      ]
    },
    {
      "keyword": "Lock & Deadlock",
      "topic": "데이터베이스",
      "level": {
        "concept": "락(Lock)은 동시에 같은 데이터를 접근할 때 충돌을 방지하기 위한 제어 장치이며, 데드락(Deadlock)은 두 개 이상의 트랜잭션이 서로가 가진 자원을 기다리며 무한 대기 상태에 빠지는 현상이다.",
        "intermediate": "락은 Shared Lock(읽기 락)과 Exclusive Lock(쓰기 락)으로 구분된다. Shared Lock은 데이터 읽기만 허용하며 여러 트랜잭션이 동시에 획득 가능하다. Exclusive Lock은 데이터 변경을 위한 락으로, 한 트랜잭션만 획득 가능하다. 또한 락은 적용 범위에 따라 Row-level(행 단위), Table-level(테이블 단위)로 나뉜다. 데드락은 순환 대기 구조를 가지며, DB는 타임아웃이나 선제 종료로 해결한다.",
        "advanced": "락 적용 방식에 따라 비관적 락(Pessimistic Lock)과 낙관적 락(Optimistic Lock)으로 구분된다. 비관적 락은 충돌이 발생할 것이라 가정하고 실제 DB 락을 사용하여 동시성을 제어한다. 반면 낙관적 락은 충돌이 드물다고 가정하고 버전 정보나 타임스탬프를 이용해 변경 시점에만 충돌을 검사한다. 실무에서는 데드락 예방을 위해 자원 접근 순서를 통일하거나, 트랜잭션 범위를 최소화한다. PostgreSQL이나 MySQL InnoDB는 자동 데드락 감지 후 트랜잭션 중단(Rollback)으로 처리한다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Transaction.md"
      ]
    },
    {
      "keyword": "RDB vs NoSQL",
      "topic": "데이터베이스",
      "level": {
        "concept": "관계형 데이터베이스(RDB)는 테이블 기반, 스키마 정형 구조를 따르며 SQL을 사용한다. NoSQL은 문서, 키-값, 그래프 등 다양한 비정형 데이터를 유연하게 처리할 수 있다.",
        "intermediate": "RDB는 데이터 무결성과 JOIN 처리에 강점이 있고, NoSQL은 수평 확장성과 스키마 유연성, 대용량 처리에서 강점을 가진다. RDB: MySQL, PostgreSQL / NoSQL: MongoDB, Redis, Cassandra 등",
        "advanced": "RDB는 ACID를 보장하며 일관성 중심이고, NoSQL은 BASE(Basically Available, Soft-state, Eventual consistency) 원칙에 따라 분산성과 가용성을 우선한다. 상황에 맞는 하이브리드 구조도 많이 사용된다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/SQL%EA%B3%BC%20NOSQL%EC%9D%98%20%EC%B0%A8%EC%9D%B4.md"
      ]
    },
    {
      "keyword": "CAP 이론",
      "topic": "데이터베이스",
      "level": {
        "concept": "CAP 이론은 분산 시스템에서 동시에 만족할 수 없는 세 가지 속성(C: 일관성, A: 가용성, P: 네트워크 분할 허용성)을 설명하는 이론이다.",
        "intermediate": "분산 시스템은 보통 세 가지 중 두 가지 속성만 만족할 수 있으며, 선택에 따라 CP, AP, CA 구조로 나뉜다. 예: CP(DB는 일관성 우선), AP(NoSQL은 가용성 우선)",
        "advanced": "CAP 이론은 BASE 이론과 함께 NoSQL 시스템을 설계할 때 중요한 기준이 되며, 네트워크 지연, 장애 발생 시 어떤 속성을 포기할 것인지 판단하는 기준점으로 작용한다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/CAP_theorem",
        "https://www.cs.cornell.edu/andru/cs711/2002fa/reading/brewer.pdf"
      ]
    },
    {
      "keyword": "Statement vs PreparedStatement",
      "topic": "데이터베이스",
      "level": {
        "concept": "Statement는 단순 SQL 실행 객체이고, PreparedStatement는 미리 컴파일된 SQL을 재사용 가능한 객체이다. 둘 다 자바 JDBC에서 많이 사용된다.",
        "intermediate": "PreparedStatement는 파라미터를 바인딩하여 SQL을 사전에 컴파일한다. 이 방식은 반복 실행에서 성능이 좋고 SQL Injection 방지에 효과적이다. 반면 Statement는 쿼리 문자열을 매번 새로 분석하기 때문에 효율이 낮고 보안에 취약하다.",
        "advanced": "PreparedStatement는 DB 드라이버 레벨에서 내부적으로 SQL을 파싱하고 캐싱하기 때문에 대량 배치 처리나 동일 구조 반복 쿼리 시 매우 효과적이다. 실무에서는 커넥션 풀과 함께 PreparedStatement 캐싱 여부도 성능에 큰 영향을 미친다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/PreparedStatement.md"
      ]
    },
    {
      "keyword": "PK, FK, 제약조건",
      "topic": "데이터베이스",
      "level": {
        "concept": "PK(Primary Key)는 테이블에서 각 행을 유일하게 식별하는 컬럼이며, FK(Foreign Key)는 다른 테이블의 PK를 참조한다. 제약조건은 데이터 무결성을 강제하는 규칙이다.",
        "intermediate": "PK는 반드시 NOT NULL + UNIQUE 속성을 가진다. FK는 참조 무결성을 위해 설정되며, ON DELETE CASCADE, ON UPDATE SET NULL 등의 옵션으로 참조 행동을 정의할 수 있다. CHECK, DEFAULT, UNIQUE 등 다양한 제약도 있다.",
        "advanced": "복합 PK는 두 개 이상의 컬럼으로 구성되고, FK는 성능 상 주의가 필요하며 많은 양의 데이터에서 조인 성능에 영향을 줄 수 있다. 제약조건은 설계 단계에서 데이터 정합성뿐 아니라 조회 효율에도 영향을 준다."
      },
      "sources": [
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/%5BDB%5D%20Key.md"
      ]
    },
    {
      "keyword": "샤딩 / 파티셔닝",
      "topic": "데이터베이스",
      "level": {
        "concept": "샤딩은 데이터를 여러 물리적 서버에 분산 저장하는 기술이며, 파티셔닝은 하나의 테이블을 논리적으로 나누는 구조다. 둘 다 대용량 데이터를 효율적으로 관리하고 성능을 향상시키기 위한 분산 전략이다.",
        "intermediate": "샤딩은 수평 확장(Scale-out) 방식으로 동일한 스키마의 데이터를 여러 서버에 분산시키며, 각 샤드는 독립적인 데이터베이스로 작동한다. 파티셔닝은 Range(범위), List(목록), Hash(해시), Composite(복합) 등 다양한 방식으로 구현되며, 같은 DB 내에서 테이블을 물리적으로 분할하지만 논리적으로는 하나의 테이블로 접근한다. 샤딩은 데이터 접근을 위한 Proxy나 라우팅 로직이 필요하다.",
        "advanced": "샤딩은 높은 확장성을 제공하지만 분산 트랜잭션의 어려움, 샤드 간 조인 제한, Global Secondary Index 구현의 복잡성 같은 제약이 존재한다. 샤드 키 선택은 데이터 분포, 액세스 패턴을 고려해야 하며, 리밸런싱 전략도 중요하다. 파티셔닝은 파티션 프루닝(불필요한 파티션 제외)을 통한 쿼리 최적화, 파티션 단위 백업/복구, 로컬/글로벌 인덱스 관리 등 세밀한 설계가 필요하다. 실제 대규모 시스템에서는 샤딩과 파티셔닝을 함께 사용하는 복합 아키텍처를 구축하여 각각의 장점을 활용한다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Partition_(database)",
        "https://en.wikipedia.org/wiki/Shard_(database_architecture)"
      ]
    },
    {
      "keyword": "데이터 정합성 / 무결성",
      "topic": "데이터베이스",
      "level": {
        "concept": "데이터 정합성은 데이터가 서로 모순 없이 일관되게 유지되는 것을 말하며, 무결성은 데이터가 정의된 규칙을 위반하지 않는 상태를 의미한다. 이는 데이터베이스의 신뢰성과 정확성을 보장하기 위한 필수적인 개념이다.",
        "intermediate": "정합성 확보를 위해 PK(Primary Key), FK(Foreign Key), UNIQUE, CHECK, NOT NULL 같은 제약조건이 사용된다. 도메인 무결성은 데이터 타입, 형식, 값의 범위를 제한하고, 참조 무결성은 FK를 통한 테이블 간 관계를 보장한다. 또한 트랜잭션과 락, 트리거, 어플리케이션 레벨 검증 등도 함께 사용된다.",
        "advanced": "정합성은 다중 시스템 간 데이터 동기화에도 적용되며, CDC(Change Data Capture)는 데이터 변경을 실시간으로 추적하고, MVCC(Multi-Version Concurrency Control)는 동시성을 제어한다. 분산 시스템에서는 강한 일관성(Strong Consistency)과 결과적 일관성(Eventual Consistency) 중 선택해야 하며, 샤딩 환경에서는 CAP 이론에 따라 일관성과 가용성 사이의 균형이 중요하다. 대용량 분산 DB에서는 BASE(Basically Available, Soft state, Eventual consistency) 이론과 정합성 관리 전략이 중요하다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Data_integrity",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Anomaly.md"
      ]
    },
    {
      "keyword": "ORM",
      "topic": "데이터베이스",
      "level": {
        "concept": "ORM(Object-Relational Mapping)은 객체 지향 언어의 객체와 관계형 데이터베이스의 테이블을 자동으로 매핑해주는 기술이다. SQL 없이 DB를 다룰 수 있도록 해준다.",
        "intermediate": "JPA, Hibernate(Java), Django ORM, SQLAlchemy(Python) 등이 대표적인 구현체다. ORM은 개발 생산성과 유지보수성을 높이지만, 성능 이슈(N+1 문제, Lazy Loading 등)를 유발할 수 있다. N+1 문제는 연관 관계가 있는 엔티티를 조회할 때, 부모 엔티티를 조회하는 1번의 쿼리와 각 부모 엔티티의 자식 엔티티를 조회하는 N번의 쿼리가 추가로 발생하는 문제를 말한다.",
        "advanced": "ORM에서는 Dirty Checking(변경 감지), Entity Lifecycle, JPQL, Criteria API, 복합키 처리 등 다양한 개념을 알아야 하며, 실무에서는 Native Query와 병행 사용하며 성능/복잡도를 조율한다. N+1 문제는 Fetch Join, EntityGraph, BatchSize 설정 등을 통해 해결할 수 있다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Object–relational_mapping",
        "https://spring.io/guides/gs/accessing-data-jpa/"
      ]
    },

    {
      "keyword": "프로세스",
      "topic": "운영체제",
      "level": {
        "concept": "프로세스는 실행 중인 프로그램이다. 예를 들어 카카오톡이나 메모장을 실행하면 그것이 하나의 프로세스가 된다. 이 프로세스는 CPU 시간, 메모리, 파일 등을 운영체제로부터 할당받아 동작하며, 사용자마다 각각 독립된 공간에서 실행된다.",
        "intermediate": "프로세스는 '생성 → 준비 → 실행 → 대기 → 종료' 같은 상태를 가지며, 이 상태들은 운영체제의 스케줄러에 의해 관리된다. 각 프로세스는 고유한 PID(프로세스 ID)를 가지고, 주소 공간(코드, 데이터, 힙, 스택)을 독립적으로 사용한다.",
        "advanced": "복잡한 시스템에서는 여러 프로세스가 동시에 실행되기 때문에, 운영체제는 이들 간 통신을 위한 IPC(프로세스 간 통신) 방식을 제공한다. 대표적으로 메시지 큐, 파이프, 공유 메모리 등이 있으며, 프로세스는 계층적으로 부모-자식 관계로 구성될 수 있다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#프로세스와-스레드의-차이",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Process.md"
      ]
    },
    {
      "keyword": "스레드",
      "topic": "운영체제",
      "level": {
        "concept": "스레드는 하나의 프로세스 내에서 실제로 작업을 수행하는 실행 단위이다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 이들은 코드를 공유하되 스택과 레지스터는 독립적으로 가진다.",
        "intermediate": "멀티스레드는 한 프로세스 안에서 여러 작업을 동시에 처리할 수 있도록 하며, 자원 공유로 인한 성능 효율성을 높인다. 하지만 스레드 간 동기화 문제가 발생할 수 있으며, 이를 위해 락이나 세마포어 같은 제어 메커니즘이 필요하다.",
        "advanced": "스레드는 사용자 수준(User-level)과 커널 수준(Kernel-level)으로 나뉘며, 사용자 수준에서는 운영체제 관여 없이 사용자 프로그램이 직접 스케줄링한다. 커널 수준 스레드는 운영체제의 커널이 스케줄링하며, 커널의 자원 소비가 더 크지만 시스템 자원과 직접 연결된다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#프로세스와-스레드의-차이",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Thread.md"
      ]
    },
    {
      "keyword": "컨텍스트 스위칭",
      "topic": "운영체제",
      "level": {
        "concept": "컨텍스트 스위칭은 운영체제가 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 다른 프로세스나 스레드로 전환하는 과정이다. 마치 회의 중 한 발표자가 내려오고 다음 발표자가 올라오는 상황과 같다.",
        "intermediate": "CPU는 동시에 여러 작업을 처리할 수 없기 때문에, 매우 빠른 속도로 작업을 전환하면서 처리한다. 이때 현재 작업의 상태는 PCB 등에 저장되고, 다음 작업의 상태가 불러와진다. 이 작업을 반복하면서 다중 작업 환경이 실현된다.",
        "advanced": "컨텍스트 스위칭은 시스템 성능에 영향을 준다. 스위칭 과정에서 캐시 무효화, 메모리 접근 지연 등이 발생할 수 있으며, 빈번한 전환은 오히려 성능 저하를 유발할 수 있다. 따라서 운영체제는 컨텍스트 스위칭의 빈도를 최소화하도록 설계된다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#프로세스와-스레드의-차이",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Process%20vs%20Thread.md"
      ]
    },
    {
      "keyword": "사용자 모드 / 커널 모드",
      "topic": "운영체제",
      "level": {
        "concept": "컴퓨터는 두 가지 실행 모드를 가진다: 사용자 모드와 커널 모드. 일반 프로그램은 사용자 모드에서 실행되며, 하드웨어 자원에 직접 접근할 수 없다. 반면, 운영체제의 핵심인 커널은 커널 모드에서 실행되며 시스템 전체에 대한 권한을 가진다.",
        "intermediate": "사용자 모드에서 프로그램이 파일 시스템이나 메모리 등 시스템 자원을 요청하면 시스템 콜을 통해 커널 모드로 전환된다. 이때 모드 전환이 일어나고, 작업이 끝나면 다시 사용자 모드로 돌아간다. 이는 보안과 안정성을 확보하기 위한 구조다.",
        "advanced": "모드 전환은 단순히 코드 레벨에서 이루어지는 것이 아니라 하드웨어의 모드 비트를 변경하여 이루어진다. 또한 커널 모드에서 문제가 발생하면 시스템 전체가 멈출 수 있으므로, 운영체제는 모드 전환을 최소화하면서 효율을 높이는 구조를 설계한다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#프로세스와-스레드의-차이",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/User%20vs%20Kernel%20Mode.md"
      ]
    },
    {
      "keyword": "PCB",
      "topic": "운영체제",
      "level": {
        "concept": "PCB(Process Control Block)는 프로세스의 상태 정보를 담고 있는 운영체제 내부의 자료 구조이다. 프로세스가 생성되면 운영체제는 그 프로세스를 추적하기 위해 PCB를 생성한다.",
        "intermediate": "PCB에는 프로세스의 ID(PID), 현재 상태(ready, running 등), 다음에 실행할 명령어 주소, 사용 중인 메모리 정보, 열려 있는 파일 목록 등이 포함된다. 이 정보는 프로세스 전환 시 저장 및 복원에 사용된다.",
        "advanced": "PCB는 운영체제의 핵심 영역(커널 공간)에 위치하며 사용자 프로그램이 직접 접근할 수 없다. 이를 통해 보안을 유지하고, CPU 스케줄러는 PCB를 기준으로 어떤 프로세스를 실행할지 판단한다. PCB는 스케줄링, 자원 관리, 상태 전이의 중심이다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#pcb",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Process%20Control%20Block.md"
      ]
    },
    {
      "keyword": "페이징",
      "topic": "운영체제",
      "level": {
        "concept": "페이징은 물리적 메모리를 고정된 크기의 블록(프레임)으로 나누고, 프로세스의 가상 주소 공간도 동일한 크기의 블록(페이지)으로 나눠서 매핑하는 메모리 관리 기법이다. 이를 통해 연속된 메모리 공간이 없어도 프로그램을 실행할 수 있다.",
        "intermediate": "페이지 테이블은 가상 페이지 번호를 물리 프레임 번호에 매핑하는 구조로, 각 프로세스마다 별도의 페이지 테이블이 생성된다. 주소 변환은 CPU의 MMU가 처리하며, TLB라는 캐시를 사용해 속도를 개선할 수 있다.",
        "advanced": "페이징은 외부 단편화를 줄이지만, 내부 단편화가 발생할 수 있다. 또한, 페이지 크기와 페이지 테이블의 크기, TLB 미스율은 전체 메모리 성능에 직접적인 영향을 주므로 시스템 설계 시 고려되어야 한다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#페이징",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Paging.md"
      ]
    },
    {
      "keyword": "세그멘테이션",
      "topic": "운영체제",
      "level": {
        "concept": "세그멘테이션은 메모리를 논리적인 단위(세그먼트)로 나누어 관리하는 방식으로, 예를 들어 코드, 데이터, 스택 등이 각기 다른 세그먼트로 나뉜다. 각 세그먼트는 크기가 다를 수 있으며, 사용자에게 논리적 구조를 제공한다.",
        "intermediate": "세그멘트 테이블에는 각 세그먼트의 시작 주소(base)와 길이(limit)가 저장된다. 주소 변환 시에는 세그먼트 번호를 통해 베이스 주소를 찾아 실제 물리 주소를 계산한다.",
        "advanced": "세그멘테이션은 프로그램 구조에 적합하다는 장점이 있지만, 외부 단편화가 발생할 수 있고, 세그먼트의 크기가 가변적이기 때문에 동적 할당 및 해제가 복잡하다. 현대 시스템에서는 페이징과 세그멘테이션을 혼합해 사용하는 경우가 많다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#세그멘테이션",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Segmentation.md"
      ]
    },
    {
      "keyword": "가상 메모리",
      "topic": "운영체제",
      "level": {
        "concept": "가상 메모리는 실제 물리 메모리보다 큰 메모리 공간을 사용하는 것처럼 보이게 하는 기술이다. 프로세스는 전체 프로그램을 한 번에 메모리에 올리지 않고 필요한 부분만 적재하여 효율적인 자원 사용이 가능하다.",
        "intermediate": "가상 메모리는 주로 페이징을 기반으로 하며, 페이지 부재(Page Fault)가 발생하면 디스크에서 해당 데이터를 메모리로 불러온다. 이 과정을 요구 페이징(Demand Paging)이라고 한다.",
        "advanced": "가상 메모리는 주소 공간 격리를 통해 보안을 높이고, 여러 프로세스가 독립적으로 실행될 수 있게 한다. 또한 스와핑, 페이지 교체 알고리즘 등과 밀접하게 연관되어 있으며 성능 튜닝에 중요한 역할을 한다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#가상-메모리",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Virtual%20Memory.md"
      ]
    },
    {
      "keyword": "페이지 교체 알고리즘",
      "topic": "운영체제",
      "level": {
        "concept": "페이지 교체 알고리즘은 가상 메모리에서 새로운 페이지를 불러와야 할 때 기존 페이지 중 어떤 것을 제거할지를 결정하는 방법이다. 가장 기본적인 알고리즘은 FIFO(선입선출)이다.",
        "intermediate": "LRU(Least Recently Used)는 가장 오랫동안 사용되지 않은 페이지를 제거하고, Optimal은 앞으로 가장 늦게 사용할 페이지를 제거하는 방식이다. 이외에도 LFU(최소 사용 횟수) 등이 있다.",
        "advanced": "페이지 교체 알고리즘의 선택은 시스템 성능에 큰 영향을 미치며, 알고리즘에 따라 페이지 부재율이 크게 달라질 수 있다. 실제 시스템에서는 구현의 복잡성과 효율성 사이에서 균형을 맞춘 알고리즘을 사용한다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#페이지-교체-알고리즘",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Page%20Replacement%20Algorithm.md"
      ]
    },
    {
      "keyword": "세마포어",
      "topic": "운영체제",
      "level": {
        "concept": "세마포어는 프로세스나 스레드 간에 자원의 접근을 제어하기 위한 동기화 도구이다. 일정 개수 이상의 접근을 막거나, 하나의 자원에 동시에 접근하지 못하게 막는 데 사용된다.",
        "intermediate": "세마포어는 정수 값을 가지며, P(Wait) 연산으로 감소하고, V(Signal) 연산으로 증가한다. 이 과정을 통해 임계 구역에서 동시에 여러 프로세스가 실행되는 것을 방지할 수 있다.",
        "advanced": "세마포어는 이진 세마포어와 계수형 세마포어로 나뉘며, 각각 뮤텍스와 유사하거나 복수 개의 자원을 제어하는 데 사용된다. 다만, 잘못된 사용은 교착 상태(Deadlock)나 기아(Starvation)를 발생시킬 수 있어 신중한 설계가 필요하다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#세마포어",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Semaphore.md"
      ]
    },
    {
      "keyword": "CPU 스케줄링",
      "topic": "운영체제",
      "level": {
        "concept": "CPU 스케줄링은 여러 프로세스가 실행을 기다릴 때, 어떤 프로세스를 CPU에 먼저 할당할지를 결정하는 운영체제의 전략이다. 이 과정은 컴퓨터가 동시에 여러 작업을 처리하는 것처럼 보이게 한다.",
        "intermediate": "대표적인 스케줄링 알고리즘에는 FCFS(선입선출), SJF(최단 작업 우선), Priority(우선순위), RR(라운드 로빈) 등이 있다. 각각은 대기 시간, 응답 시간, 처리량 등 성능에 영향을 준다. CPU 스케줄링은 선점형(Preemptive)과 비선점형(Non-preemptive)으로 나뉘며, 선점형은 우선순위가 높은 프로세스가 CPU를 강제로 점유할 수 있고, 비선점형은 한번 CPU를 할당받으면 작업이 완료될 때까지 CPU를 사용한다.",
        "advanced": "실제 운영체제에서는 다단계 큐, 멀티레벨 피드백 큐 등의 복합 스케줄링 기법이 사용된다. 스케줄러는 응답 속도와 처리 효율 사이에서 균형을 맞추며, 사용자와 시스템 성능에 최적화되도록 설계된다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#cpu-스케줄러",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/CPU%20Scheduling.md"
      ]
    },
    {
      "keyword": "뮤텍스",
      "topic": "운영체제",
      "level": {
        "concept": "뮤텍스(Mutex)는 여러 스레드나 프로세스가 공유 자원에 동시에 접근하지 못하도록 막아주는 동기화 도구이다. 뮤텍스를 이용하면 오직 하나의 실행 흐름만 자원을 사용할 수 있다.",
        "intermediate": "뮤텍스는 '잠금(Lock)'과 '해제(Unlock)' 메커니즘을 기반으로 한다. 하나의 스레드가 자원을 사용 중일 때 다른 스레드는 대기하게 되며, 자원 사용이 끝나면 다음 대기 스레드가 접근한다.",
        "advanced": "뮤텍스는 교착 상태를 일으킬 수 있으므로 사용 시 주의가 필요하다. 재진입 가능 여부, 우선순위 역전 문제 등의 해결이 중요하며, 운영체제 커널 수준에서 구현되기도 한다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#lock",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Synchronization.md"
      ]
    },
    {
      "keyword": "임계구역",
      "topic": "운영체제",
      "level": {
        "concept": "임계구역(Critical Section)은 두 개 이상의 스레드나 프로세스가 동시에 실행되면 안 되는 코드 영역이다. 예를 들어, 같은 변수나 파일을 동시에 수정하면 데이터가 꼬일 수 있는데, 이를 방지하기 위한 보호 영역이다.",
        "intermediate": "임계구역 문제를 해결하기 위해 뮤텍스, 세마포어, 모니터 같은 동기화 기법이 사용된다. 이 기법들은 상호배제, 진행, 한정 대기 등의 조건을 충족해야 한다.",
        "advanced": "정확한 임계구역 구현은 다중 프로세서 환경에서 매우 중요하다. 경쟁 조건(Race Condition), 우선순위 역전, 기아 등의 문제가 발생하지 않도록 신중한 설계가 필요하다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#critical-section",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Critical%20Section.md"
      ]
    },
    {
      "keyword": "데드락",
      "topic": "운영체제",
      "level": {
        "concept": "데드락(교착 상태)은 두 개 이상의 프로세스가 서로의 자원을 기다리며 무한정 대기하는 상황을 말한다. 마치 두 사람이 서로의 열쇠를 가지고 있어 문을 열 수 없는 상황과 같다.",
        "intermediate": "데드락이 발생하려면 네 가지 조건(상호 배제, 점유와 대기, 비선점, 환형 대기)이 모두 만족되어야 한다. 이 조건 중 하나라도 깨면 데드락을 방지할 수 있다.",
        "advanced": "운영체제는 데드락을 방지하기 위해 자원 순서 지정, 타임아웃, 은행가 알고리즘 등의 방법을 사용한다. 실무에서는 데드락 탐지 후 프로세스 종료로 해결하는 경우도 있다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#deadlock",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Deadlock.md"
      ]
    },
    {
      "keyword": "시스템 콜",
      "topic": "운영체제",
      "level": {
        "concept": "시스템 콜(System Call)은 사용자 프로그램이 운영체제의 기능(파일 열기, 메모리 할당 등)을 사용하기 위해 호출하는 인터페이스이다. 사용자 모드에서 실행 중인 프로그램은 시스템 콜을 통해 커널 모드로 진입한다.",
        "intermediate": "시스템 콜의 예로는 read(), write(), fork(), exec() 등이 있으며, 호출 시 모드 비트를 전환하여 안전하게 커널 기능을 사용한다. 시스템 콜 없이 사용자 프로그램은 하드웨어에 직접 접근할 수 없다.",
        "advanced": "시스템 콜 인터페이스는 운영체제마다 다를 수 있으며, 비용이 높기 때문에 호출 횟수를 최소화하는 것이 중요하다. 또한, 시스템 콜은 인터럽트 벡터를 통해 커널 코드로 점프하여 수행된다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/OS/README.md#system-call",
        "https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/System%20Call.md"
      ]
    },
    {
      "keyword": "OSI 7계층",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "OSI 7계층은 컴퓨터 간 네트워크 통신을 이해하기 쉽게 7단계로 나눈 구조이다. 물리 → 데이터링크 → 네트워크 → 전송 → 세션 → 표현 → 응용 계층으로 구성되어 있으며, 각 계층은 특정 기능을 담당한다.",
        "intermediate": "각 계층은 캡슐화(encapsulation)를 통해 데이터를 하위 계층으로 넘기며, 전송 계층(TCP/UDP)은 신뢰성 있는 전송을 담당하고, 응용 계층은 HTTP, FTP 등 사용자 프로토콜이 포함된다.",
        "advanced": "실제 시스템에서는 TCP/IP 4계층 모델을 더 많이 사용하지만, OSI 7계층은 디버깅, 프로토콜 설계, 보안 분석 시 구조적 사고를 위한 기본 개념으로 활용된다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/OSI_model",
        "https://developer.mozilla.org/en-US/docs/Glossary/OSI_model"
      ]
    },
    {
      "keyword": "TCP / UDP",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "TCP와 UDP는 데이터를 전송하는 전송 계층의 대표 프로토콜이다. TCP는 연결지향 방식으로 신뢰성 있는 전송을 보장하며, UDP는 비연결형으로 빠르고 단순한 전송에 적합하다.",
        "intermediate": "TCP는 3-way 핸드셰이크를 통해 연결을 설정하고, 데이터 순서를 보장하며, 오류를 검출하고 재전송한다. 반면 UDP는 실시간 스트리밍, 게임 등에서 빠른 전송을 우선시하며 오류 처리는 직접 해야 한다.",
        "advanced": "TCP는 혼잡 제어, 흐름 제어, 윈도우 기반 전송 등을 통해 안정성을 극대화하며, UDP는 멀티캐스트 지원 및 헤더 오버헤드가 적어 IoT 기기나 DNS, VoIP 등에서도 많이 활용된다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Transmission_Control_Protocol",
        "https://en.wikipedia.org/wiki/User_Datagram_Protocol"
      ]
    },
    {
      "keyword": "3-way handshake",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "3-way 핸드셰이크는 TCP 연결을 설정하는 초기 절차로, 클라이언트와 서버 간에 세 번의 패킷을 주고받는다. 이를 통해 서로의 존재와 포트 상태를 확인하고 연결을 안정적으로 시작한다.",
        "intermediate": "1) 클라이언트가 SYN을 보냄, 2) 서버가 SYN-ACK로 응답, 3) 클라이언트가 ACK를 보냄. 이 과정이 완료되면 연결이 확립되고, 데이터 전송이 시작된다.",
        "advanced": "3-way 핸드셰이크는 시퀀스 번호(ISN) 초기 설정, 보안 검증(방어 목적), RTT 측정 등의 역할도 하며, SYN flood 같은 공격에 대비해 SYN 쿠키 방식이 도입되기도 한다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment",
        "https://velog.io/@juno7803/TCP-3-way-Handshake"
      ]
    },
    {
      "keyword": "4-way handshake",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "4-way 핸드셰이크는 TCP 연결을 종료할 때 사용하는 절차이다. 종료는 연결 설정과 달리 양방향 모두에서 독립적으로 수행되며, 네 번의 패킷이 교환된다.",
        "intermediate": "1) 클라이언트가 FIN 전송, 2) 서버가 ACK로 응답, 3) 서버가 FIN 전송, 4) 클라이언트가 ACK로 응답. 이로써 연결이 양방향 모두 종료된다.",
        "advanced": "연결 종료는 TIME_WAIT 상태를 포함하여 종료 후에도 일정 시간 동안 포트 재사용을 방지한다. 이 상태는 재전송 패킷이 유입되는 것을 방지하기 위한 보안/신뢰성 구조이다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_termination",
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/Network/README.md"
      ]
    },
    {
      "keyword": "HTTP / HTTPS",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "HTTP는 클라이언트(브라우저)와 서버 간 데이터를 주고받는 통신 프로토콜이다. HTTPS는 HTTP에 SSL/TLS 암호화를 적용하여 보안성을 높인 버전이다.",
        "intermediate": "HTTP는 비연결성, 무상태(stateless) 기반이며, HTTPS는 TLS를 통해 통신 내용을 암호화하고 인증서를 사용해 서버를 검증한다. 일반적으로 HTTPS는 443번 포트를 사용하고, HTTP는 80번을 사용한다.",
        "advanced": "HTTPS는 TLS 핸드셰이크에서 공개키 방식으로 대칭키를 교환하고, 이후 데이터는 대칭키로 암호화된다. 또한 최신 HTTP/2, HTTP/3는 멀티플렉싱, UDP 기반 전송을 사용하여 성능과 보안을 모두 개선하고 있다."
      },
      "sources": [
        "https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview",
        "https://en.wikipedia.org/wiki/HTTPS"
      ]
    },
    {
      "keyword": "HTTP GET vs POST",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "GET과 POST는 HTTP 요청 방식 중 두 가지이다. GET은 데이터를 URL에 포함시켜 서버에 요청하며, POST는 데이터를 HTTP 메시지 본문에 포함시켜 요청한다.",
        "intermediate": "GET은 주소창에서 볼 수 있어 캐싱에 유리하지만 보안에 취약하고, 길이 제한이 있다. POST는 로그인, 결제와 같은 민감한 데이터 전송에 사용되며, 요청 본문(body)에 데이터를 담기 때문에 보안과 유연성이 좋다.",
        "advanced": "REST API 설계에서는 GET은 조회용, POST는 리소스 생성용으로 엄격히 구분하며, 둘의 idempotency(멱등성) 특성도 다르다. GET은 여러 번 요청해도 같은 결과지만, POST는 상태를 바꾸므로 그렇지 않다."
      },
      "sources": [
        "https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET",
        "https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST"
      ]
    },
    {
      "keyword": "DNS",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "DNS(Domain Name System)는 사람이 기억하기 쉬운 도메인 이름을 IP 주소로 변환해주는 시스템이다. 예: google.com → 142.250.196.14",
        "intermediate": "DNS 요청은 로컬 DNS → 루트 DNS → 최상위 도메인(TLD) DNS → 권한 있는 DNS 서버 순으로 진행된다. 클라이언트는 이 과정을 거쳐 서버의 IP 주소를 획득한다.",
        "advanced": "DNS는 보안 위협에 노출될 수 있어, DNSSEC 같은 인증 기술이 도입되며, DNS 캐싱은 응답 속도를 높이는 동시에 TTL(Time To Live)을 통해 갱신 주기를 관리한다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Domain_Name_System",
        "https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_domain_name"
      ]
    },
    {
      "keyword": "IP / 서브넷 / 게이트웨이",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "IP는 인터넷상에서 장치를 구분하기 위한 주소이다. 서브넷은 IP 주소를 나누는 방식으로 네트워크 구획을 정의하고, 게이트웨이는 외부 네트워크와 내부 네트워크 사이를 연결해주는 장치이다.",
        "intermediate": "IP 주소는 IPv4(32비트)와 IPv6(128비트)로 나뉘며, 서브넷 마스크는 네트워크/호스트 영역을 구분하는 데 사용된다. 게이트웨이는 기본적으로 인터넷 통신 시 반드시 거치는 통로다.",
        "advanced": "서브넷팅은 네트워크를 세분화하여 보안성과 효율을 높이고, CIDR(클래스 없는 주소 체계)은 유연한 주소 할당을 가능하게 한다. 게이트웨이는 NAT, 라우팅, 방화벽 등 다양한 역할도 수행할 수 있다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/IP_address",
        "https://en.wikipedia.org/wiki/Subnetwork",
        "https://en.wikipedia.org/wiki/Gateway_(telecommunications)"
      ]
    },
    {
      "keyword": "NAT / PAT",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "NAT(Network Address Translation)는 사설 IP를 공인 IP로 변환하여 인터넷 통신이 가능하게 해주는 기술이다. PAT(Port Address Translation)은 하나의 공인 IP에 여러 포트를 할당해 여러 장치를 동시에 인터넷에 연결시킬 수 있게 한다.",
        "intermediate": "NAT는 가정이나 회사에서 사설 IP(192.168.x.x 등)를 공인 IP로 매핑하며, PAT는 포트 번호까지 매핑하여 다수의 장비가 하나의 IP를 공유할 수 있도록 한다.",
        "advanced": "NAT는 주소 고갈 문제를 해결하지만, 종단 간 통신(End-to-End)을 제한하며, WebRTC나 P2P 연결에서 문제가 생길 수 있다. 이를 해결하기 위한 기술로는 STUN, TURN 등이 있다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Network_address_translation",
        "https://en.wikipedia.org/wiki/Port_address_translation"
      ]
    },
    {
      "keyword": "ARP",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "ARP(Address Resolution Protocol)는 IP 주소에 해당하는 MAC 주소를 찾기 위한 프로토콜이다. 같은 네트워크 상의 장치 간 통신을 위해 사용된다.",
        "intermediate": "호스트가 통신하려는 대상의 MAC 주소를 모를 경우 ARP 요청을 보내고, 해당 IP를 가진 장치가 ARP 응답을 보낸다. 이 정보는 ARP 캐시에 저장되어 반복 요청을 줄인다.",
        "advanced": "ARP 스푸핑은 공격자가 자신의 MAC 주소를 다른 IP 주소에 매핑시켜 트래픽을 가로채는 보안 공격이다. 이를 방지하기 위해 동적 ARP 검사(DAI) 등의 보안 장치가 사용된다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Address_Resolution_Protocol",
        "https://www.cloudflare.com/learning/ddos/glossary/address-resolution-protocol-arp/"
      ]
    },
    {
      "keyword": "DHCP",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "DHCP는 Dynamic Host Configuration Protocol의 약자로, 장치가 자동으로 IP 주소를 받을 수 있게 해주는 프로토콜이다. 인터넷에 연결할 때 IP 주소를 수동으로 입력하지 않아도 되게 해준다.",
        "intermediate": "DHCP 서버는 클라이언트의 요청을 받아 IP 주소, 서브넷 마스크, 게이트웨이, DNS 등 네트워크 설정 정보를 임시로 할당한다. 요청 → 제안 → 요청 → 확인의 4단계 핸드셰이크(DORA) 방식으로 진행된다.",
        "advanced": "DHCP는 IP 풀 관리, 리스 타임 갱신, 주소 충돌 방지 등의 기능도 포함한다. 기업 환경에서는 DHCP Relay를 통해 다른 서브넷에서도 DHCP 요청을 중계할 수 있다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol",
        "https://www.cloudflare.com/learning/network-layer/what-is-dhcp/"
      ]
    },
    {
      "keyword": "CDN",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "CDN(Content Delivery Network)은 전 세계에 분산된 서버를 이용해 사용자와 가까운 곳에서 콘텐츠를 빠르게 제공하는 기술이다. 웹 페이지 로딩 속도를 높이기 위해 사용된다.",
        "intermediate": "정적 리소스(이미지, JS, CSS 등)를 전 세계 CDN 서버에 캐싱해두고, 요청 시 가장 가까운 서버에서 데이터를 제공한다. 이는 대역폭 절감, 병목 방지에도 효과적이다.",
        "advanced": "CDN은 요청 라우팅, 캐시 무효화 정책, TLS 가속 등 고급 기능을 통해 성능과 보안을 모두 확보한다. Akamai, Cloudflare, Amazon CloudFront 등이 대표적인 CDN 서비스 제공업체이다."
      },
      "sources": [
        "https://www.cloudflare.com/learning/cdn/what-is-a-cdn/",
        "https://en.wikipedia.org/wiki/Content_delivery_network"
      ]
    },
    {
      "keyword": "SSL / TLS",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 인터넷 상에서 데이터를 안전하게 전송하기 위한 암호화 통신 프로토콜이다. HTTPS는 TLS를 기반으로 한다.",
        "intermediate": "TLS는 서버 인증서 기반 공개키 암호화를 통해 세션 키를 교환하고, 이후 실제 데이터는 대칭키로 빠르게 암호화되어 전송된다. SSL은 이전 버전으로, 현재는 TLS가 사용된다.",
        "advanced": "TLS는 핸드셰이크 과정, 레코드 프로토콜, 세션 재개 등을 포함한다. TLS 1.3은 불필요한 핸드셰이크 절차를 줄여 보안성과 속도를 동시에 개선한 최신 표준이다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Transport_Layer_Security",
        "https://www.cloudflare.com/learning/ssl/what-is-ssl/"
      ]
    },
    {
      "keyword": "포트번호",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "포트번호는 하나의 IP 주소에서 여러 개의 서비스를 구분하기 위한 숫자이다. 예를 들어 웹(HTTP)은 80번, HTTPS는 443번 포트를 기본으로 사용한다.",
        "intermediate": "포트는 0~65535까지 있으며, 0~1023은 well-known 포트(표준), 1024~49151은 등록된 포트, 49152~65535는 임시 포트로 사용된다. 클라이언트는 일반적으로 임시 포트를 자동 할당받는다.",
        "advanced": "방화벽, 프록시 서버, NAT 등은 포트 기반으로 트래픽을 필터링하거나 라우팅한다. 포트 스캐닝 공격을 방어하기 위해 일부 시스템에서는 특정 포트를 막거나 모니터링한다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Port_(computer_networking)",
        "https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml"
      ]
    },
    {
      "keyword": "패킷 전송 흐름",
      "topic": "컴퓨터네트워크",
      "level": {
        "concept": "패킷 전송 흐름은 클라이언트가 서버로 요청을 보내고 응답을 받기까지의 전체 네트워크 흐름을 말한다. 브라우저 주소창에 URL을 입력하는 순간부터 여러 단계가 진행된다.",
        "intermediate": "브라우저 입력 → DNS 조회 → TCP 연결(3-way handshake) → HTTP 요청 → 서버 처리 → 응답(HTML/CSS 등) → 렌더링 → 종료(4-way handshake) 순서로 진행된다.",
        "advanced": "이 과정에서 OSI 계층별로 동작이 나뉘며, 응용계층은 HTTP, 전송계층은 TCP, 네트워크계층은 IP, 데이터링크/물리계층은 이더넷으로 구성된다. 패킷 단위로 캡슐화 및 역캡슐화가 반복되며 전송된다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/Network/README.md#웹-통신의-흐름",
        "https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work"
      ]
    },
    {
      "keyword": "배열",
      "topic": "자료구조",
      "level": {
        "concept": "배열(Array)은 같은 타입의 데이터를 연속된 공간에 저장하며, 인덱스를 통해 O(1) 시간에 요소에 접근할 수 있는 자료구조이다.",
        "intermediate": "배열은 검색은 빠르지만 삽입/삭제가 느리다. 중간에 요소를 삽입하면 그 이후 요소들을 이동시켜야 하므로 최악의 경우 시간 복잡도는 O(n)이 된다. 또한 크기가 고정되어 있어 동적 확장 시에는 새로운 배열을 할당해야 한다.",
        "advanced": "동적 배열 구조인 Python의 list, Java의 ArrayList는 내부적으로 배열을 사용하되 크기를 자동 조정한다. resize는 amortized O(1)이지만, 메모리 재할당 시 전체 복사 비용이 들며 캐시 지역성이 좋아 탐색에 유리하다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md"
      ]
    },
    {
      "keyword": "연결 리스트",
      "topic": "자료구조",
      "level": {
        "concept": "연결 리스트(Linked List)는 각 노드가 데이터와 다음 노드를 가리키는 포인터를 가지는 구조로, 삽입/삭제가 O(1)인 동적 자료구조이다.",
        "intermediate": "배열과 달리 메모리가 연속되지 않아 동적 할당이 가능하고, 노드를 중간에 추가하거나 삭제할 때 다른 노드의 포인터만 수정하면 된다. 하지만 특정 인덱스에 접근하려면 순차 탐색이 필요해 O(n)의 탐색 비용이 든다.",
        "advanced": "단일 연결 리스트 외에도 양방향 연결 리스트(Doubly Linked List), 원형 연결 리스트(Circular Linked List)가 있다. GC 없는 환경에선 메모리 누수 방지와 포인터 관리가 중요하며, 실제 구현 시 dummy head 사용으로 코드 복잡도를 줄인다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md"
      ]
    },
    {
      "keyword": "스택",
      "topic": "자료구조",
      "level": {
        "concept": "스택(Stack)은 LIFO(Last In First Out) 구조로, 가장 나중에 삽입된 데이터가 가장 먼저 제거되는 자료구조이다. 주로 재귀, 괄호 검사, DFS 등에 활용된다.",
        "intermediate": "스택은 배열이나 연결 리스트로 구현되며, push/pop 연산은 O(1) 시간에 가능하다. 웹 브라우저의 뒤로가기, 함수 콜 스택 등도 스택 기반 구조이다.",
        "advanced": "스택은 DFS, 후위 표기식 계산기, 수식 파싱, 트리 순회(전위/후위) 등에서 핵심 도구로 사용된다. 재귀 호출은 내부적으로 스택 프레임을 생성하므로, 스택 오버플로우 방지를 위한 tail recursion 최적화 기법이 중요하다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md"
      ]
    },
    {
      "keyword": "큐 / 덱",
      "topic": "자료구조",
      "level": {
        "concept": "큐(Queue)는 FIFO(First In First Out) 구조이며, 덱(Deque)은 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조이다. 큐는 BFS, 작업 큐 등에 사용된다.",
        "intermediate": "큐는 배열, 연결 리스트, 또는 원형 배열로 구현되며, 삽입은 rear, 삭제는 front에서 발생한다. 덱은 양방향 처리에 특화되어 sliding window, 캐시 구현 등에 사용된다.",
        "advanced": "덱은 Python의 collections.deque처럼 최적화된 자료구조가 있으며, 우선순위 큐, 큐 기반 스케줄링 알고리즘에서도 활용된다. 원형 큐 구현 시 포인터 처리와 overflow 방지 로직이 중요하다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md"
      ]
    },
    {
      "keyword": "해시 테이블",
      "topic": "자료구조",
      "level": {
        "concept": "해시 테이블(Hash Table)은 키(Key)를 해시 함수로 변환하여 배열 인덱스로 매핑하고, 해당 위치에 값을 저장하는 구조로 평균 O(1)에 데이터 검색이 가능하다.",
        "intermediate": "충돌(Collision)을 처리하기 위해 Separate Chaining(리스트로 연결)이나 Open Addressing(빈 자리 탐색)을 사용한다. 해시 함수는 분산도, 충돌율에 큰 영향을 주며, 테이블 크기 증가 시 재해싱(rehash)이 필요하다.",
        "advanced": "실제 언어에서는 Python의 dict, Java의 HashMap, C++의 unordered_map 등이 있으며, 해시 키 충돌 문제는 보안 공격에도 악용될 수 있다. 성능을 위해 load factor, resizing 전략, prime-sized 배열 등이 활용된다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md"
      ]
    },
    {
      "keyword": "힙",
      "topic": "자료구조",
      "level": {
        "concept": "힙(Heap)은 완전 이진 트리의 일종으로, 부모 노드가 자식 노드보다 항상 크거거나 작다는 조건을 만족한다. 최대 힙(Max Heap)은 부모 ≥ 자식, 최소 힙(Min Heap)은 부모 ≤ 자식 구조를 가진다.",
        "intermediate": "삽입과 삭제는 로그 시간에 가능하며, 우선순위 큐(Priority Queue)로 주로 사용된다. 배열로 구현하며 인덱스를 기반으로 부모와 자식 간 관계를 계산한다. 삽입은 맨 뒤에 삽입 후 위로 정렬(Heapify up), 삭제는 루트 제거 후 아래로 정렬(Heapify down)한다.",
        "advanced": "힙은 Dijkstra 알고리즘, 스케줄러, Top-K 문제 등에 쓰인다. Python에서는 heapq 모듈이 min heap 기반이며, max heap은 값을 음수화하여 구현한다. 이진 힙 외에도 피보나치 힙, d-ary 힙 등이 존재한다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md"
      ]
    },
    {
      "keyword": "트리",
      "topic": "자료구조",
      "level": {
        "concept": "트리(Tree)는 계층적 데이터 구조로, 노드들이 부모-자식 관계로 연결된 비순환 그래프이다. 루트 노드에서 시작하여 자식 노드로 뻗어나가는 구조이다.",
        "intermediate": "이진 트리(Binary Tree)는 자식이 최대 2개이며, 트리 순회 방식(전위, 중위, 후위)을 통해 구조를 탐색한다. 완전 이진 트리, 포화 이진 트리, 균형 이진 트리 등의 세부 구조가 있다.",
        "advanced": "트리는 파일 시스템, 컴파일러의 파싱 트리, 디렉토리 구조 등에 사용된다. AVL 트리, Red-Black Tree 같은 자가 균형 트리는 삽입/삭제 시에도 균형을 유지하여 최악의 시간 복잡도를 보장한다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md"
      ]
    },
    {
      "keyword": "이진 탐색 트리",
      "topic": "자료구조",
      "level": {
        "concept": "이진 탐색 트리(BST)는 왼쪽 자식은 루트보다 작고, 오른쪽 자식은 루트보다 큰 값을 가지는 이진 트리이다.",
        "intermediate": "탐색, 삽입, 삭제의 평균 시간 복잡도는 O(log n)이며, 균형이 깨지면 O(n)까지 저하될 수 있다. 중복 처리, 삭제 시 후계 노드 찾기 등이 실제 구현에서 중요한 이슈다.",
        "advanced": "Red-Black Tree, AVL Tree는 BST의 단점을 보완하기 위해 고안된 자가 균형 트리이다. Treap, Splay Tree 같은 고급 BST 구조도 있다. 대부분의 언어의 TreeMap, TreeSet 등은 Red-Black Tree 기반이다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md"
      ]
    },
    {
      "keyword": "그래프",
      "topic": "자료구조",
      "level": {
        "concept": "그래프(Graph)는 정점(Vertex)과 간선(Edge)으로 구성되며, 객체 간 관계를 표현할 수 있는 자료구조이다. 방향/무방향, 가중치 유무에 따라 구분된다.",
        "intermediate": "인접 행렬, 인접 리스트 방식으로 구현하며, BFS(너비 우선 탐색), DFS(깊이 우선 탐색)을 통해 순회한다. MST(최소 신장 트리), 최단 경로(Dijkstra, Floyd-Warshall) 문제에서 중심적으로 활용된다.",
        "advanced": "위상 정렬, 사이클 탐지, 유니온 파인드, SCC(강한 연결 요소), 다익스트라, 벨만포드, A* 알고리즘 등으로 확장된다. 실무에서는 네트워크 라우팅, 추천 시스템, 그래프 데이터베이스 등에서 사용된다."
      },
      "sources": [
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md"
      ]
    },
    {
      "keyword": "트라이",
      "topic": "자료구조",
      "level": {
        "concept": "트라이(Trie)는 문자열을 저장하고 탐색하기 위한 트리 기반 자료구조이다. 특히 공통 접두사를 공유함으로써 검색 성능을 향상시킨다.",
        "intermediate": "각 노드는 문자를 저장하고, 경로를 따라가면서 전체 문자열이 구성된다. 삽입, 탐색, 자동완성(Auto-complete) 기능에 적합하며, 공간 복잡도는 높지만 빠른 탐색이 가능하다.",
        "advanced": "트라이는 사전(Dictionary), 검색어 자동완성, T9 입력기 등에 쓰이며, 압축 트라이(Compressed Trie), 라딕스 트리(Radix Tree), 서픽스 트리(Suffix Trie) 같은 확장 형태도 존재한다."
      },
      "sources": [
        "https://en.wikipedia.org/wiki/Trie",
        "https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md"
      ]
    },
    {
      "keyword": "정렬",
      "topic": "알고리즘",
      "level": {
        "concept": "정렬(Sorting)은 데이터를 오름차순 또는 내림차순으로 정렬하는 알고리즘이다. 정렬은 탐색, 중복 제거, 전처리 단계 등에서 자주 사용된다.",
        "intermediate": "버블, 삽입, 선택 정렬은 단순하지만 느리며, 퀵 정렬, 병합 정렬, 힙 정렬은 O(n log n)의 시간복잡도를 갖는다. 정렬 후 이진 탐색, 투 포인터, 슬라이딩 윈도우 등의 알고리즘을 적용하기 위한 사전 작업으로 필수다.",
        "advanced": "실제 프로덕션 환경에서는 Timsort(합병 + 삽입 혼합)가 가장 많이 쓰이며, Counting Sort나 Radix Sort 같은 분포 기반 정렬은 특수한 상황(정수 범위 제한)에 매우 유리하다. 정렬은 많은 알고리즘의 기본 전제가 되므로 선제적으로 고려해야 한다."
      }
    },
    {
      "keyword": "이진 탐색",
      "topic": "알고리즘",
      "level": {
        "concept": "이진 탐색은 정렬된 배열에서 원하는 값을 빠르게 찾기 위한 알고리즘이다. 탐색 범위를 절반씩 줄이므로 O(log n)의 시간복잡도를 가진다.",
        "intermediate": "이진 탐색은 값 그 자체를 찾을 때도 쓰지만, 조건을 만족하는 값의 최소/최대 경계를 찾는 데도 자주 사용된다. 예: 특정 값을 넘지 않는 가장 큰 수, 최소한의 비용, 최대 가능 거리 계산 등.",
        "advanced": "Parametric Search 또는 Lower/Upper Bound 탐색으로 확장되며, 이진 탐색은 DP 최적화, 최적화 문제의 이분화, 구현 문제에서 핵심 기법으로 활용된다. 이분 탐색이 가능한 구조인지 먼저 판단하는 것이 핵심이다."
      }
    },
    {
      "keyword": "투 포인터",
      "topic": "알고리즘",
      "level": {
        "concept": "투 포인터는 두 개의 인덱스를 활용하여 배열이나 문자열에서 조건을 만족하는 구간이나 쌍을 찾는 알고리즘이다. 특히 정렬된 데이터에서 매우 효율적이다.",
        "intermediate": "두 포인터를 앞뒤에서 이동시키며 조건을 만족하는지 확인한다. 예: 특정 합을 갖는 두 수 찾기, 최소 길이 부분 수열, 같은 값 쌍 제거, 연속 구간의 최대 합 등 다양한 문제에서 사용된다.",
        "advanced": "정렬 + 투 포인터 조합은 O(n^2)을 O(n)으로 최적화하며, 슬라이딩 윈도우나 이진 탐색과 결합해 다양한 고급 문제(예: 결정 문제, 수열 최적화)에도 사용된다. 효율적인 경계 조건 설정이 관건이다."
      }
    },
    {
      "keyword": "슬라이딩 윈도우",
      "topic": "알고리즘",
      "level": {
        "concept": "슬라이딩 윈도우는 고정 또는 가변 길이의 구간을 배열이나 문자열 위에서 이동시키며 상태를 갱신하는 방식이다. 연속된 구간 합, 최대/최소 길이 문제에 자주 사용된다.",
        "intermediate": "이전 결과를 기반으로 다음 결과를 빠르게 갱신할 수 있어 전체를 다시 계산하지 않아도 된다. 예: k개의 원소 평균, 아나그램, 부분 배열 중 특정 조건 만족 최소 길이.",
        "advanced": "해시, 덱, 누적합 등과 결합하여 고급 문제에 사용된다. 최소 윈도우 서브스트링, 캐시 시뮬레이션, 연속된 고유 문자 수 등 다양한 실전 문제에서 필수 기법이다."
      }
    },
    {
      "keyword": "해시 알고리즘",
      "topic": "알고리즘",
      "level": {
        "concept": "해시 알고리즘은 데이터를 키-값 구조로 저장하여 빠르게 탐색하거나 중복 여부를 판단하는 데 사용된다. 평균 시간복잡도는 O(1)에 가깝다.",
        "intermediate": "중복 확인, 등장 횟수 카운팅, 그룹핑(예: 아나그램 그룹), 사전 기반 탐색 등에 유용하다. 해시 충돌을 고려한 충돌 해결 방식도 중요하다.",
        "advanced": "Rolling Hash, Bloom Filter, Count-Min Sketch 같은 고급 기법으로 확장된다. 문자열 탐색, 캐싱, 보안(Hash 함수: SHA, MD5)까지 다양한 분야에서 핵심 도구로 활용된다."
      }
    },
    {
      "keyword": "BFS / DFS",
      "topic": "알고리즘",
      "level": {
        "concept": "BFS는 너비 우선 탐색, DFS는 깊이 우선 탐색이다. 둘 다 그래프나 트리 구조를 순회하는 기초적인 알고리즘이다.",
        "intermediate": "BFS는 큐를 이용하며 가까운 노드부터 탐색하고, 최단 거리 문제(가중치 없는 그래프)에 유리하다. DFS는 스택(재귀) 기반이며, 깊은 경로를 먼저 탐색하므로 백트래킹이나 순열 조합 문제에 적합하다.",
        "advanced": "DFS는 사이클 탐지, 위상 정렬, SCC(강한 연결 요소), DFS tree 구성 등에 쓰인다. BFS는 다차원 배열에서 최단 거리 계산, 토마토 문제, 미로 찾기, 레벨 단위 탐색 등에서 자주 사용된다."
      }
    },
    {
      "keyword": "다익스트라 / 벨만포드",
      "topic": "알고리즘",
      "level": {
        "concept": "두 알고리즘 모두 그래프에서 단일 출발점 기준의 최단 경로를 구하는 알고리즘이다.",
        "intermediate": "다익스트라는 양의 가중치만 있는 경우에 사용되며, 우선순위 큐 + 그리디 방식으로 동작한다. 벨만포드는 음수 가중치까지 고려할 수 있고, 음수 사이클 존재 여부도 판별 가능하다.",
        "advanced": "다익스트라는 heapq를 활용해 O(E log V)에 동작하며, 실무에서는 지하철/지도 앱, 네트워크 지연 최소화 등에서 사용된다. 벨만포드는 음수 사이클 판단이 필요한 금융 알고리즘 등에서 사용된다."
      }
    },
    {
      "keyword": "유니온 파인드",
      "topic": "알고리즘",
      "level": {
        "concept": "유니온 파인드(Disjoint Set)은 노드들이 같은 집합에 속해 있는지 판단하고, 두 집합을 합치는 알고리즘이다.",
        "intermediate": "find 연산은 루트를 찾고, union 연산은 두 루트를 연결한다. 부모 노드를 배열로 관리하고, 경로 압축(Path Compression)과 union by rank를 적용해 시간복잡도를 O(α(n))까지 줄인다.",
        "advanced": "크루스칼 알고리즘, 사이클 탐지, 네트워크 연결, 친구 관계 그룹, 유사도 분류 등에 자주 사용된다. 상호 배타적 집합을 구성하는 데 효율적이다."
      }
    },
    {
      "keyword": "분할 정복",
      "topic": "알고리즘",
      "level": {
        "concept": "분할 정복(Divide and Conquer)은 문제를 작은 단위로 분할하고, 각각을 재귀적으로 해결한 뒤 결과를 병합하는 전략이다.",
        "intermediate": "대표적인 예로 병합 정렬(Merge Sort), 이진 탐색, 퀵 정렬, Karatsuba 곱셈 등이 있다. 분할 조건과 병합 로직을 잘 정의하는 것이 핵심이다.",
        "advanced": "분할 정복은 메모리 사용량과 스택 깊이 문제에 주의가 필요하다. Strassen 행렬 곱셈, DAC 기반 FFT(Fast Fourier Transform) 알고리즘 등으로도 활용된다."
      }
    },
    {
      "keyword": "동적 계획법",
      "topic": "알고리즘",
      "level": {
        "concept": "동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 작은 부분 문제로 나누고, 결과를 재사용하며 효율적으로 푸는 방법이다.",
        "intermediate": "Memoization(상향식), Tabulation(하향식)으로 구분된다. 피보나치 수열, 배낭 문제, 최단 경로, 최장 증가 수열, 편집 거리, 행렬 곱셈 최소 비용 등에 사용된다.",
        "advanced": "DP는 점화식 수립이 핵심이며, 1차원/2차원 배열, 트리 DP, 비트 마스크 DP 등 고급 기법으로 확장된다. 반복적 + 누적형 문제에서 효과적이며, Greedy로 풀 수 없는 최적화 문제에 강력하다."
      }
    }
  ]